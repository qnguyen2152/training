/* ---> This file is automatically generated by ../core/API_Generator.pl! <--- */
/***************************************************************************
*================ Copyright by Continental Automotive GmbH =================
****************************************************************************
*
* Titel        : Navi_api.cpp
*
* Description  : EMPTY API BODIES / TOOLBASED GENERATION
*
* Environment  : JGP 2014 / WIN_XP
*
* Author       : Cao Yiran
*
****************************************************************************/


/****************************************************************************
** Header Files (Only those that are needed in this file)
****************************************************************************/
#include "GAUXL_C1.h"
#include "api_c1.h"
#include "string.h"
#include "apim_apiinterface.h"
#include "apim_backdoorinterface.h"
#if ( APIM_DIAG_MODE_ENABLED == Yes )
#	include "apimdiagnosis_interface.h"
#endif
#include "APIM_BackdoorInterface.h"
#include "apimgr_gentraceinterface.h"
#include "Navi_Api.hpp"
#include "Navi_Api_i.hpp"

/***************************************************************************
* API FUNCTION DEFINITIONS
***************************************************************************/
bool Navi_boVehicleMove(void) /* @status Implemented */
{
    /******************************************************************************************
    * Get the Vehicle movement status
    * @response  => ONCHANGE
    * @return    => bool
    * @param	 void
    ******************************************************************************************/  
    VEL_tstDpoolData stVEL;
    bool boActive = false;
    APIM_boGetData(APIM_nDId_VEL_stDpoolData, &stVEL, (uint16)sizeof(stVEL));
    boActive = stVEL.VEL_boVehicleMove;
    return boActive;
}
bool boGetTPVisible(uint8 u8Index) /* @status Implemented */
{
    /******************************************************************************************
    * Get the TP visible status
    * @response  => ONCHANGE
    * @return    => bool
    * @param	 u8Index - 0:TBT 1:TBT_Dest 2:AV 3:AV_PhoneNum
    ******************************************************************************************/

    bool boTPVisible = 0x0;
    EEP_tstDpoolData stCommon;
    TBT_tstDpoolData stTbt;
    AVM_tstDpoolData stAvm;
    uint32 u32ErrorCode;

    APIM_boGetData(APIM_nDId_EEP_stDpoolData, &stCommon, (uint16)sizeof(stCommon));
    APIM_boGetData(APIM_nDId_TBT_stDpoolData, &stTbt, (uint16)sizeof(stTbt));
    APIM_boGetData(APIM_nDId_AVM_stDpoolData, &stAvm, (uint16)sizeof(stAvm));

    switch (u8Index)
    {
    case HMI::WRS::TBT_TP:
        if (GAUXL_u16WStrlen((uint16*)APIM_pvGetFreezeBuffer(APIM_nDId_TPITBT_stDpoolData), &u32ErrorCode))
        {
            if (stTbt.boTPOnOff == false)
            {
                boTPVisible = 0x0;
            }
            else
            {
                boTPVisible = 0x1;
            }
        }
        else
        {
            boTPVisible = 0x0;
        }
        break;
    case HMI::WRS::TBT_Dest_TP:
        if (GAUXL_u16WStrlen((uint16*)APIM_pvGetFreezeBuffer(APIM_nDId_TPITBTDestName_stDpoolData), &u32ErrorCode))
        {
	    boTPVisible = 0x1;
        }
        else
        {
            boTPVisible = 0x0;
        }
        break;
    case HMI::WRS::AV_TP:
        if (GAUXL_u16WStrlen((uint16*)APIM_pvGetFreezeBuffer(APIM_nDId_TPIAV_stDpoolData), &u32ErrorCode))
        {
            if ((stAvm.boTPOnOff == false) || (stAvm.u8TPValidity == 0x00))
            {
                boTPVisible = 0x0;
            }
            else
            {
                boTPVisible = 0x1;
            }
        }
        else
        {
            boTPVisible = 0x0;
        }
        break;
    case HMI::WRS::AV_PhoneNum_TP:
        if (GAUXL_u16WStrlen((uint16*)APIM_pvGetFreezeBuffer(APIM_nDId_TPIAVPhone_stDpoolData), &u32ErrorCode))
        {
            if ((stAvm.boTPOnOff == false) || (stAvm.u8TPValidity == 0x00))
            {
                boTPVisible = 0x0;
            }
            else
            {
                boTPVisible = 0x1;
            }
        }
        else
        {
            boTPVisible = 0x0;
        }
        break;
    default:
        boTPVisible = 0x0;
        break;
    }

    //if the result of Strlen is error, TP text is not displayed
    if (u32ErrorCode != 0)
    {
        boTPVisible = 0x0;
    }
    else
    {
        //Do Nothing
    }

    return (boTPVisible);
}

uint16 Navi_u16GetTbtArrowPosition ( uint8 u8Index ) /* @status Prototype */ 
{
    /****************************************************************************************** 
     * Get TBT Arrow position
     * @response  => ONCHANGE
     * @return    => uint16
      * @param	 u8Index - Index for return data
     ******************************************************************************************/

    TBT_tstDpoolData stTbt;
    uint16 u16Ret = 0x00;
    uint8 u8BarGraphLevel = 0x00;

    APIM_boGetData(APIM_nDId_TBT_stDpoolData, &stTbt, (uint16)sizeof(stTbt));

    u8BarGraphLevel = (stTbt.u8BarGraphLevel < 100) ? stTbt.u8BarGraphLevel : 0;

    switch (u8Index)
    {
        //PosY
    case 1:
        u16Ret = (361 - (1.5*(100 - u8BarGraphLevel)));
        break;
        //BG Hight
    case 2:
        u16Ret = (180 - (1.5*(100 - u8BarGraphLevel)));
        break;
    default:
        break;
    }

    return (u16Ret);
}
float32 Navi_f32GetTbtLoadingAngle ( bool boIsInit ) /* @status Prototype */ 
{
    /****************************************************************************************** 
     * Get TBT loading image angle
     * @response  => NONE
     * @return    => float
      * @param	 boIsInit - 0 : no init, 1 : init angle
     ******************************************************************************************/

    static float32 f32TbtLoadingAngle = 0x00;

    if (boIsInit)
    {
        f32TbtLoadingAngle = 270;
    }
    else
    {
        if (f32TbtLoadingAngle > 0) 
        {
            f32TbtLoadingAngle -= 20;
        }
        else
        {
            f32TbtLoadingAngle = 340;
        }
    }

    return (f32TbtLoadingAngle);
}
uint8 Navi_u8GetTbtBGType ( void ) /* @status Prototype */ 
{
    /****************************************************************************************** 
     * Get TBT BG Type
     * @response  => ONCHANGE
     * @return    => uint8
      * @param void
     ******************************************************************************************/

    TBT_tstDpoolData stTbt;
    uint8 u8TbtBGType = 0x00;

    APIM_boGetData(APIM_nDId_TBT_stDpoolData, &stTbt, (uint16)sizeof(stTbt));

    switch (stTbt.u8DisplayType)
    {
    case 0x13:
    case 0x14:
    case 0x17:
    case 0x18:
    case 0x19:
    case 0xFE:
        u8TbtBGType = 1;
        break;

    case 0x11:
        u8TbtBGType = 2;
        break;

    case 0x12:
        u8TbtBGType = 3;
        break;

    case 0x2B:
    case 0x2C:
    case 0x2D:
    case 0x2E:
        u8TbtBGType = 5;
        break;

    case 0x1F:
        if (stTbt.u8Direction == 0x00)
        {
            u8TbtBGType = 2;
        }
        else
        {
            u8TbtBGType = 3;
        }
        break;

    case 0x0D:
    case 0x20:
    case 0x21:
        if (stTbt.u8Direction < 5)
        {
            u8TbtBGType = 1;
        }
        else if (stTbt.u8Direction < 9)
        {
            u8TbtBGType = 2;
        }
        else if (stTbt.u8Direction < 12)
        {
            u8TbtBGType = 3;
        }
        else
        {
            u8TbtBGType = 1;
        }
        break;


    default:
        u8TbtBGType = 0;
        break;
    }

    return (u8TbtBGType);
}
uint8 Navi_u8GetTBTRegion ( void ) /* @status Prototype */ 
{
    /****************************************************************************************** 
     * Get TBT region data
     * @response  => ONCHANGE
     * @return    => uint8
      * @param void
     ******************************************************************************************/

    /*1 : KOR, 2:Gen, 3:MidEast, 4:EU,Russia, 5:AUS, 6:CAN, 7:USA, 8:CHN, 9:BRA*/
    EEP_tstDpoolData stCommon;
    uint8 u8Region = 0;

    APIM_boGetData( APIM_nDId_EEP_stDpoolData , &stCommon, (uint16)sizeof(stCommon) );
    switch(stCommon.EEP_u8Region)
    {
    case 1:
        u8Region = 0;
        break;
    case 8:
        u8Region = 2;
        break;
    default:
        u8Region = 1;
        break;
    }

    return ( u8Region );
}
bool Navi_boCheckTbtEstDistOver100 ( void ) /* @status Prototype */ 
{
    /****************************************************************************************** 
     * Check the TBT Estimated distance is bigger than 100.
     * @response  => ONCHANGE
     * @return    => bool
      * @param void
     ******************************************************************************************/

    TBT_tstDpoolData stTbt;
    bool boValueOverHundred;

    APIM_boGetData(APIM_nDId_TBT_stDpoolData, &stTbt, (uint16)sizeof(stTbt));
    if (stTbt.u16EstDistOverZero >= 100)
    {
        boValueOverHundred = True;
    }
    else
    {
        boValueOverHundred = False;
    }

    return (boValueOverHundred);
}
uint8 Navi_u8GetTbtEstDistScale ( void ) /* @status Prototype */ 
{
    /****************************************************************************************** 
     * Get the TBT Scale value for Estimated Distance
     * @response  => ONCHANGE
     * @return    => uint8
     * @param void
     ******************************************************************************************/

    TBT_tstDpoolData stTbt;
    uint8 u8EstDistScale;

    APIM_boGetData(APIM_nDId_TBT_stDpoolData, &stTbt, (uint16)sizeof(stTbt));
    u8EstDistScale = stTbt.u8EstDistScale;

    return (u8EstDistScale);
}
/***APIs for Advance TBRT***/
uint8 Navi_u8GetTurnListCnt ( void ) /* @status Prototype */
{
    /******************************************************************************************
     * Get the Advance TBT Card Turn List Count
     * @response  => ONCHANGE
     * @return    => uint8
     * @param void
     ******************************************************************************************/
    TPITBTAdvanced_tstDpoolData stCardInfo;

    APIM_boGetData(APIM_nDId_TPITBTAdvanced_stDpoolData, &stCardInfo, (uint16)sizeof(stCardInfo));

    return stCardInfo.u8TurnListCnt;
}
uint8 Navi_u8GetCardInfoStatus(uint8 u8CardIndex)
{
    /******************************************************************************************
    * Get status of a CardInfo by Index
    *   Return 0 to hide CardInfo
    *   Others: show CardInfo
    * @response  => ONCHANGE
    * @return    => uint8; 0: skip card info; 1: show card info
    * @param     u8CardIndex: Index of CardInfo
    ******************************************************************************************/
    uint8 u8CardStatus = 0;
    uint8 u8TurnListCnt = Navi_u8GetTurnListCnt();

    if (u8CardIndex < u8TurnListCnt)
    {
        u8CardStatus = 1;
    }

    return u8CardStatus;
}
RSST_tenBitmapID Navi_enGetAdvTBTSchematicBmpID ( uint8 u8Region, uint8 u8CardIndex ) /* @status Prototype */ 
{
    /****************************************************************************************** 
     * Get the Bitmap id for Schematic Diagram
     * @response  => ONCHANGE
     * @return    => RSST_tenBitmapID
     * @param	 u8Region - Area Information for schematics
     ******************************************************************************************/

    TPITBTAdvanced_tstDpoolData stAdvTbt;
    RSST_tenBitmapID enRSSTID = RSST_nInvalidBitmap;
    uint8 u8DisplayType = 0;

    APIM_boGetData( APIM_nDId_TPITBTAdvanced_tstDpoolData , &stAdvTbt, (uint16)sizeof(stAdvTbt) );
    
    if(u8CardIndex > stAdvTbt.u8TurnListCnt || u8CardIndex < 1)
    {
        return enRSSTID;
    }

    u8DisplayType = stAdvTbt.u8DisplayType[u8CardIndex - 1];

    if(u8DisplayType >= 0x41 && u8DisplayType<=0xCB)
        {
            uint8 u8Idx = 0;
            for (u8Idx = 0; u8Idx < sizeof(NAVI::astSchematicsID) / sizeof(NAVI::tstSchematicsBmpID); u8Idx++)
            {
                if (u8DisplayType == NAVI::astSchematicsID[u8Idx].u8DisplayType)
                {
                    switch(u8Region)
                    {
                    case 0:
                        enRSSTID = NAVI::astSchematicsID[u8Idx].enDomRSSTID;
                        break;
                    case 1:
                        enRSSTID = NAVI::astSchematicsID[u8Idx].enOtherRSSTID;
                        break;
                    case 2:
                        enRSSTID = NAVI::astSchematicsID[u8Idx].enChnRSSTID;
                        break;
                    default:
                        break;
                    }
                    break;
                }
            }
        }
        else if ((u8DisplayType == 0x0D) || (u8DisplayType == 0x1F) || (u8DisplayType >= 0x11 && u8DisplayType <= 0x14) || (u8DisplayType >= 0x17 && u8DisplayType <= 0x21) || (u8DisplayType >= 0x17 && u8DisplayType <= 0x21) || (u8DisplayType >= 0x2B && u8DisplayType <= 0x2E))
        {
            uint8 u8Idx = 0;
            for (u8Idx = 0; u8Idx < sizeof(NAVI::astPreInfoExceptTBTBmpID) / sizeof(NAVI::tstPreInfoExceptTBTBmpID); u8Idx++)
            {
                if (u8DisplayType == NAVI::astPreInfoExceptTBTBmpID[u8Idx].u8DisplayType && u8Direction == NAVI::astPreInfoExceptTBTBmpID[u8Idx].u8TBT_Direction)
                {
                    switch (u8Region)
                    {
                    case 0:
                        enRSSTID = NAVI::astPreInfoExceptTBTBmpID[u8Idx].enDomRSSTID;
                        break;
                    case 1:
                        enRSSTID = NAVI::astPreInfoExceptTBTBmpID[u8Idx].enOtherRSSTID;
                        break;
                    case 2:
                        enRSSTID = NAVI::astPreInfoExceptTBTBmpID[u8Idx].enChnRSSTID;
                        break;
                    default:
                        break;
                    }
                    break;
                }
            }
        }
    
    return ( enRSSTID );
}
uint8 Navi_u8GetAdvTbtDisplayType ( uint8 u8CardIndex) /* @status Prototype */ 
{
    /****************************************************************************************** 
     * Get the Advance TBT display type
     * @response  => ONCHANGE
     * @return    => uint8
     * @param u8CardIndex: Index of CardInfo (1-->2)
     ******************************************************************************************/
    
    TPITBTAdvanced_tstDpoolData stAdvTbt;
    uint8 u8DisplayType = 0xFF;

    APIM_boGetData( APIM_nDId_TBT_stDpoolData , &stAdvTbt, (uint16)sizeof(stAdvTbt) );

    switch(stAdvTbt.u8TurnListCnt)
    {
        case 1: u8DisplayType = stAdvTbt.u8DisplayType[0]; break;
        case 2: u8DisplayType = stAdvTbt.u8DisplayType[1]; break;
        case 3: u8DisplayType = stAdvTbt.u8DisplayType[2]; break;
    }

    return ( u8DisplayType );
}
/*** APIs for Advance TBRT ***/
uint8 Navi_u8GetTBTDestType ( void ) /* @status Prototype */ 
{
    /****************************************************************************************** 
     * Get the TBT Destination Type
     * @response  => ONCHANGE
     * @return    => uint8
      * @param void
     ******************************************************************************************/

    TBT_tstDpoolData stTbt;
    uint8 u8TBTDestType;

    APIM_boGetData(APIM_nDId_TBT_stDpoolData, &stTbt, (uint16)sizeof(stTbt));
    u8TBTDestType = stTbt.u8EstPointType;

    return (u8TBTDestType);
}
uint16* Navi_pau16GetTBTDestName ( void ) /* @status Prototype */ 
{
    /****************************************************************************************** 
     * Get the TBT Detailed Destination Name TP
     * @response  => ONCHANGE
     * @return    => uint16*
      * @param void
     ******************************************************************************************/

    /* Note: the Dpool struct TPITBT_tstDpoolData has only one member variable */ 
    return (uint16*)APIM_pvGetFreezeBuffer( APIM_nDId_TPITBTDestName_stDpoolData );
}
uint8 Navi_u8GetEstTimeMinute ( void ) /* @status Prototype */ 
{
    /****************************************************************************************** 
     * Get Estimated Time Minute
     * @response  => ONCHANGE
     * @return    => uint8
      * @param void
     ******************************************************************************************/

    TBT_tstDpoolData stTbt;
    uint8 u8EstTimeMinute = 0x00;

    APIM_boGetData( APIM_nDId_TBT_stDpoolData , &stTbt, (uint16)sizeof(stTbt) );
    /**20131002@WoCha:No need to handle Hour in API! already cared in App.*/
    /**@WoCha:Initially, if value is 0xFF, then it needs to show -- instead of numeric value!
              but, at the moment, graphic data is not available!! */
    //if(stTbt.u8EstTimeMinute > 59U)
    //{
    //    u8EstTimeMinute = 0x00;
    //}
    //else
    //{
    //    u8EstTimeMinute = stTbt.u8EstTimeMinute;
    //}
    u8EstTimeMinute = stTbt.u8EstTimeMinute;

    return ( u8EstTimeMinute );
}
uint8 Navi_u8GetEstTimeHour ( void ) /* @status Prototype */ 
{
    /****************************************************************************************** 
     * Get Estimated Time Hour
     * @response  => ONCHANGE
     * @return    => uint8
      * @param void
     ******************************************************************************************/

    TBT_tstDpoolData stTbt;
    uint8 u8EstTimeHour = 0x00;

    APIM_boGetData( APIM_nDId_TBT_stDpoolData , &stTbt, (uint16)sizeof(stTbt) );
    /**20131002@WoCha:No need to handle Hour in API! already cared in App.*/
    /**@WoCha:Initially, if value is 0xFF, then it needs to show -- instead of numeric value!
              but, at the moment, graphic data is not available!! */
    //if(stTbt.u8EstTimeHour > 23U)
    //{
    //    u8EstTimeHour = 0x00;
    //}
    //else
    //{
    //    u8EstTimeHour = stTbt.u8EstTimeHour;
    //}
    u8EstTimeHour = stTbt.u8EstTimeHour;

    return ( u8EstTimeHour );
}
uint8 Navi_u8GetEstTimeUnit ( void ) /* @status Prototype */ 
{
    /****************************************************************************************** 
     * Get Estimated Time Unit.1:AM, 2:PM
     * @response  => ONCHANGE
     * @return    => uint8
      * @param void
     ******************************************************************************************/

    TBT_tstDpoolData stTbt;
    uint8 u8EstTimeUnit = 0x00;

    APIM_boGetData( APIM_nDId_TBT_stDpoolData , &stTbt, (uint16)sizeof(stTbt) );
    u8EstTimeUnit = stTbt.u8EstTimeUnit;

    return ( u8EstTimeUnit );
}
uint8 Navi_u8GetEstTimeFormat ( void ) /* @status Prototype */ 
{
    /****************************************************************************************** 
     * Get Estimated Time Format.1:12Hours, 2:24Hours
     * @response  => ONCHANGE
     * @return    => uint8
      * @param void
     ******************************************************************************************/

    TBT_tstDpoolData stTbt;
    uint8 u8EstTimeFormat = 0x00;

    APIM_boGetData( APIM_nDId_TBT_stDpoolData , &stTbt, (uint16)sizeof(stTbt) );
    u8EstTimeFormat = stTbt.u8EstTimeFormat;

    return ( u8EstTimeFormat );
}
uint8 Navi_u8GetEstTimeType ( void ) /* @status Prototype */ 
{
    /****************************************************************************************** 
     * Get Estimated Time Type. 1:Arrival, 2:Remaining
     * @response  => ONCHANGE
     * @return    => uint8
      * @param void
     ******************************************************************************************/

    TBT_tstDpoolData stTbt;
    uint8 u8EstTimeType = 0x00;

    APIM_boGetData( APIM_nDId_TBT_stDpoolData , &stTbt, (uint16)sizeof(stTbt) );
    u8EstTimeType = stTbt.u8EstTimeType;

    return ( u8EstTimeType );
}
RSST_tenBitmapID Navi_enGetSchematicBmpID ( uint8 u8Region ) /* @status Prototype */ 
{
    /****************************************************************************************** 
     * Get the Bitmap id for Schematic Diagram
     * @response  => ONCHANGE
     * @return    => RSST_tenBitmapID
      * @param	 u8Region - Area Information for schematics
     ******************************************************************************************/

    TBT_tstDpoolData stTbt;
    RSST_tenBitmapID enRSSTID = RSST_nInvalidBitmap;

    APIM_boGetData( APIM_nDId_TBT_stDpoolData , &stTbt, (uint16)sizeof(stTbt) );

    if(stTbt.u8DisplayType >= 0x41 && stTbt.u8DisplayType<=0xCB)
    {
        uint8 u8Idx = 0;
        for (u8Idx = 0; u8Idx < sizeof(NAVI::astSchematicsID) / sizeof(NAVI::tstSchematicsBmpID); u8Idx++)
        {
            if (stTbt.u8DisplayType == NAVI::astSchematicsID[u8Idx].u8DisplayType)
            {
                switch(u8Region)
                {
                case 0:
                    enRSSTID = NAVI::astSchematicsID[u8Idx].enDomRSSTID;
                    break;
                case 1:
                    enRSSTID = NAVI::astSchematicsID[u8Idx].enOtherRSSTID;
                    break;
                case 2:
                    enRSSTID = NAVI::astSchematicsID[u8Idx].enChnRSSTID;
                    break;
                default:
                    break;
                }
                break;
            }
        }
    }
    else if ((stTbt.u8DisplayType == 0x0D) || (stTbt.u8DisplayType == 0x1F) || (stTbt.u8DisplayType >= 0x11 && stTbt.u8DisplayType <= 0x14) || (stTbt.u8DisplayType >= 0x17 && stTbt.u8DisplayType <= 0x21) || (stTbt.u8DisplayType >= 0x17 && stTbt.u8DisplayType <= 0x21) || (stTbt.u8DisplayType >= 0x2B && stTbt.u8DisplayType <= 0x2E))
    {
        uint8 u8Idx = 0;
        for (u8Idx = 0; u8Idx < sizeof(NAVI::astPreInfoExceptTBTBmpID) / sizeof(NAVI::tstPreInfoExceptTBTBmpID); u8Idx++)
        {
            if (stTbt.u8DisplayType == NAVI::astPreInfoExceptTBTBmpID[u8Idx].u8DisplayType && stTbt.u8Direction == NAVI::astPreInfoExceptTBTBmpID[u8Idx].u8TBT_Direction)
            {
                switch (u8Region)
                {
                case 0:
                    enRSSTID = NAVI::astPreInfoExceptTBTBmpID[u8Idx].enDomRSSTID;
                    break;
                case 1:
                    enRSSTID = NAVI::astPreInfoExceptTBTBmpID[u8Idx].enOtherRSSTID;
                    break;
                case 2:
                    enRSSTID = NAVI::astPreInfoExceptTBTBmpID[u8Idx].enChnRSSTID;
                    break;
                default:
                    break;
                }
                break;
            }
        }
    }
    return ( enRSSTID );
}
uint8 Navi_u8GetTbtDisplayType ( void ) /* @status Prototype */ 
{
    /****************************************************************************************** 
     * Get the TBT display type
     * @response  => ONCHANGE
     * @return    => uint8
      * @param void
     ******************************************************************************************/

    TBT_tstDpoolData stTbt;
    uint8 u8DisplayType = 0xFF;

    APIM_boGetData( APIM_nDId_TBT_stDpoolData , &stTbt, (uint16)sizeof(stTbt) );

    u8DisplayType = stTbt.u8DisplayType;

    return ( u8DisplayType );
}
bool Navi_boGetTbtCombiSideStreet ( uint8 u8CombiStreetIndex ) /* @status Prototype */ 
{
    /****************************************************************************************** 
     * Get the TBT Combined SideStreet value
     * @response  => ONCHANGE
     * @return    => bool
      * @param	 u8CombiStreetIndex - 
     ******************************************************************************************/

    TBT_tstDpoolData stTbt;
    bool boCombiSideStreet;
    uint16 u16CombiSideStreet;

    APIM_boGetData( APIM_nDId_TBT_stDpoolData , &stTbt, (uint16)sizeof(stTbt) );
    u16CombiSideStreet = stTbt.u8CombiSideStreet;

    boCombiSideStreet = (u16CombiSideStreet & (uint16)(1u<<u8CombiStreetIndex))?(On):(Off);

    return ( boCombiSideStreet );
}
bool Navi_boGetTbtSideStreet ( uint8 u8StreetIndex ) /* @status Prototype */ 
{
    /****************************************************************************************** 
     * Get the TBT SideStreet value
     * @response  => ONCHANGE
     * @return    => bool
      * @param	 u8StreetIndex - 
     ******************************************************************************************/

    TBT_tstDpoolData stTbt;
    bool boSideStreet;
    uint16 u16SideStreet;

    APIM_boGetData( APIM_nDId_TBT_stDpoolData , &stTbt, (uint16)sizeof(stTbt) );
    u16SideStreet = stTbt.u16SideStreet;

    boSideStreet = (u16SideStreet & (uint16)(1u<<u8StreetIndex))?(On):(Off);

    return ( boSideStreet );
}
uint16 Navi_u16GetTbtSideStreet ( void ) /* @status Prototype */ 
{
    /****************************************************************************************** 
     * Get TBT SideStreet value itself
     * @response  => ONCHANGE
     * @return    => uint16
      * @param void
     ******************************************************************************************/

    TBT_tstDpoolData stTbt;
    uint16 u16SideStreet;

    APIM_boGetData( APIM_nDId_TBT_stDpoolData , &stTbt, (uint16)sizeof(stTbt) );
    u16SideStreet = (stTbt.u16SideStreet << 1) | (stTbt.u16SideStreet?0x0001:0x0000);

    return ( u16SideStreet );
}
bool Navi_boIsTbtTPOnOff(void) /* @status Prototype */
{
    /****************************************************************************************** 
     * Get the TP status. True: Show, False: OFF
     * @response  => ONCHANGE
     * @return    => bool
      * @param void
     ******************************************************************************************/

    TBT_tstDpoolData stTbt;
    bool boTbtTPOnOff;

    APIM_boGetData( APIM_nDId_TBT_stDpoolData , &stTbt, (uint16)sizeof(stTbt) );
    boTbtTPOnOff = stTbt.boTPOnOff;

    return ( boTbtTPOnOff );
}
uint8 Navi_u8GetTbtDirection(void) /* @status Prototype */
{
    /****************************************************************************************** 
     * Get the TBT Direction value
     * @response  => ONCHANGE
     * @return    => uint8
      * @param void
     ******************************************************************************************/

    TBT_tstDpoolData stTbt;
    uint8 u8Direction;

    APIM_boGetData( APIM_nDId_TBT_stDpoolData , &stTbt, (uint16)sizeof(stTbt) );
    u8Direction = stTbt.u8Direction;

    return ( u8Direction );
}
bool Navi_boCheckTbtDistToTurnOver100(void) /* @status Prototype */
{
    /****************************************************************************************** 
     * Check the TBT distance to TurnPoint is bigger than 100.
     * @response  => ONCHANGE
     * @return    => bool
      * @param void
     ******************************************************************************************/

    TBT_tstDpoolData stTbt;
    bool boValueOverHundred;

    APIM_boGetData( APIM_nDId_TBT_stDpoolData , &stTbt, (uint16)sizeof(stTbt) );
    if(stTbt.u16DistToTurnOverZero >= 100)
    {
        boValueOverHundred = True;
    }
    else
    {
        boValueOverHundred = False;
    }

    return ( boValueOverHundred );
}
uint16 Navi_u16GetTbtDistToTurnPoint(void) /* @status Prototype */
{
    /****************************************************************************************** 
     * Get the TBT distance to TurnPoint
     * @response  => ONCHANGE
     * @return    => uint16
      * @param void
     ******************************************************************************************/

    TBT_tstDpoolData stTbt;
    uint16 u16DistToTurnPoint = 0xFFFF;

    APIM_boGetData( APIM_nDId_TBT_stDpoolData , &stTbt, (uint16)sizeof(stTbt) );

    switch(stTbt.u8Scale)
    {
        case 0:
        case 3:
        case 4:
            u16DistToTurnPoint = stTbt.u16DistToTurnOverZero;
            break;
        case 1:
        case 2:
            if(stTbt.u16DistToTurnOverZero < 100)
            {
                /* Reset the u16DistToTurnPointUnderZero to 0, if not in range 0-9 */
                if(stTbt.u8DistToTurnUnderZero > 9)
                {
                    stTbt.u8DistToTurnUnderZero = 0;
                }

                /* Concatenate the u16DistToTurnOverZero and u16DistToTurnPointUnderZero*/  
                u16DistToTurnPoint = (stTbt.u16DistToTurnOverZero * 10) + stTbt.u8DistToTurnUnderZero;
            }
            else if(stTbt.u16DistToTurnOverZero >= 100)
            {
                u16DistToTurnPoint = stTbt.u16DistToTurnOverZero;
            }
            break;
        default:
            break;
    }

    if ((stTbt.u16DistToTurnOverZero > 9999) && (stTbt.u16DistToTurnOverZero != 0xFFFF) && (stTbt.u8DisplayType >= 0x41 && stTbt.u8DisplayType <= 0xCB)) u16DistToTurnPoint = 9999;
    return ( u16DistToTurnPoint );
}
uint16 Navi_u16GetTbtEstDist(void) /* @status Prototype */
{
    /****************************************************************************************** 
     * Get the TBT Estimated distance
     * @response  => ONCHANGE
     * @return    => uint16
      * @param void
     ******************************************************************************************/

    TBT_tstDpoolData stTbt;
    uint16 u16DistToDestination = 0xFFFF;

    APIM_boGetData( APIM_nDId_TBT_stDpoolData , &stTbt, (uint16)sizeof(stTbt) );

    switch(stTbt.u8EstDistScale)
    {
        case 0:
        case 3: 
        case 4: 
            u16DistToDestination = stTbt.u16EstDistOverZero;
            break;
        case 1:
        case 2:
            if(stTbt.u16EstDistOverZero < 100)
            {
                /* Reset the u16DistToTurnPointUnderZero to 0, if not in range 0-9 */
                if(stTbt.u8EstDistUnderZero > 9)
                {
                    stTbt.u8EstDistUnderZero = 0;
                }

                /* Concatenate the u16DistToDestOverZero and u8DistToDestUnderZero*/  
                u16DistToDestination = (stTbt.u16EstDistOverZero * 10) + stTbt.u8EstDistUnderZero;
            }
            else if(stTbt.u16EstDistOverZero >= 100)
            {
                u16DistToDestination = stTbt.u16EstDistOverZero;
            }
            break;
        default:
            break;
    }

    //if (u16DistToDestination > 9999)
    //{
    //    u16DistToDestination = 0xFFFF;
    //}
    //else
    //{
    //    /*Do Nothing*/
    //}

    return ( u16DistToDestination );
}
uint8 Navi_u8GetTbtBarGraphLevel(void) /* @status Prototype */
{
    /****************************************************************************************** 
     * Get the TBT Bargraph Level value
     * @response  => ONCHANGE
     * @return    => uint8
      * @param void
     ******************************************************************************************/

    TBT_tstDpoolData stTbt;
    uint8 u8BarGraphLevel = 0x00;

    APIM_boGetData( APIM_nDId_TBT_stDpoolData , &stTbt, (uint16)sizeof(stTbt) );

    //u8BarGraphLevel = (stTbt.u8BarGraphLevel == 0xFF)?(0x00):(stTbt.u8BarGraphLevel);
    u8BarGraphLevel = stTbt.u8BarGraphLevel;

    return ( u8BarGraphLevel );
}
uint8 Navi_u8GetTbtDistToTurnScale(void) /* @status Prototype */
{
    /****************************************************************************************** 
     * Get the TBT Scale value for Distance to Turn
     * @response  => ONCHANGE
     * @return    => uint8
      * @param void
     ******************************************************************************************/

    TBT_tstDpoolData stTbt;
    uint8 u8Scale;

    APIM_boGetData( APIM_nDId_TBT_stDpoolData , &stTbt, (uint16)sizeof(stTbt) );
    u8Scale = stTbt.u8Scale;

    return ( u8Scale );
}
uint16* Navi_pau16GetTBTData(void) /* @status Prototype */
{
    /****************************************************************************************** 
     * Get the TBT Destination Text
     * @response  => ONCHANGE
     * @return    => uint16*
      * @param void
     ******************************************************************************************/

    /* Note: the Dpool struct TPITBT_tstDpoolData has only one member variable */ 
    return (uint16*)APIM_pvGetFreezeBuffer(APIM_nDId_TPITBT_stDpoolData);
}
bool Navi_boGetIsDestSet(void) /* @status Prototype */
{
    /******************************************************************************************
    * Get the Status of guiadance on the HUD
    * @response  => ONCHANGE
    * @return    => bool
    * @param void
    ******************************************************************************************/
    TBT_tstDpoolData stTbt;
    bool boIsDestSet;
    APIM_boGetData(APIM_nDId_TBT_stDpoolData, &stTbt, (uint16)sizeof(stTbt));
    if (stTbt.u8DisplayType == 2 || stTbt.u8DisplayType == 6 || (stTbt.u8DisplayType >= 11 && stTbt.u8DisplayType <= 13) || (stTbt.u8DisplayType >= 15 && stTbt.u8DisplayType <= 33) || (stTbt.u8DisplayType >= 43 && stTbt.u8DisplayType <= 46) || (stTbt.u8DisplayType >= 64 && stTbt.u8DisplayType <= 203))
    {
        boIsDestSet = true;
    }
    else
    {
        boIsDestSet = false;
    }
    return boIsDestSet;
}

bool Navi_boGetTbtDistToTurnPointVisible(void) /* @status Prototype */
{
    /******************************************************************************************
    * Get the TBT distance to TurnPoint Visible property
    * @response  => ONCHANGE
    * @return    => bool
    * @param void
    ******************************************************************************************/

    bool boDistTPVisible = false;
    TBT_tstDpoolData stTbt;
    uint16 u16DistToTurnPoint = 0xFFFF;

    APIM_boGetData(APIM_nDId_TBT_stDpoolData, &stTbt, (uint16)sizeof(stTbt));
    if ((stTbt.u8DisplayType < 0x41) || (stTbt.u8DisplayType > 0xCB))
    {
        if ((stTbt.u8Scale == 255) || (stTbt.u16DistToTurnOverZero == 65535) || (stTbt.u8BarGraphLevel > 100))
        {
            boDistTPVisible = false;
        }
        else
        {
            boDistTPVisible = true;
        }
    }
    if ((stTbt.u8DisplayType >= 0x41) && (stTbt.u8DisplayType <= 0xCB))
    {
        if ((stTbt.u8Scale == 255) || (stTbt.u16DistToTurnOverZero == 65535))
        {
            boDistTPVisible = false;
        }
        else
        {
            boDistTPVisible = true;
        }
    }
    else
    {
        /*Do nothing*/
    }
    return (boDistTPVisible);
}

bool Navi_boGetBarGraphVisible(void) /* @status Prototype */
{
    /******************************************************************************************
    * Get the TBT Bar graph Visible property
    * @response  => ONCHANGE
    * @return    => bool
    * @param void
    ******************************************************************************************/

    bool boDistTPVisible = false;
    TBT_tstDpoolData stTbt;
    uint16 u16DistToTurnPoint = 0xFFFF;

    APIM_boGetData(APIM_nDId_TBT_stDpoolData, &stTbt, (uint16)sizeof(stTbt));
    
    if ((stTbt.u8Scale > 4) || (stTbt.u16DistToTurnOverZero > 9999) || (stTbt.u8BarGraphLevel > 100))
    {
        boDistTPVisible = false;
    }
    else
    {
        boDistTPVisible = true;
    }
    return (boDistTPVisible);
}
/* --- EOF --- */
